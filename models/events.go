// Code generated by SQLBoiler 4.14.2 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/v4/types"
	"github.com/volatiletech/strmangle"
)

// Event is an object representing the database table.
type Event struct {
	EventcreatorID  null.Int          `boil:"eventcreator_id" json:"eventcreator_id,omitempty" toml:"eventcreator_id" yaml:"eventcreator_id,omitempty"`
	Category        types.StringArray `boil:"category" json:"category,omitempty" toml:"category" yaml:"category,omitempty"`
	PreregisterDate null.Time         `boil:"preregister_date" json:"preregister_date,omitempty" toml:"preregister_date" yaml:"preregister_date,omitempty"`
	EndregisterDate null.Time         `boil:"endregister_date" json:"endregister_date,omitempty" toml:"endregister_date" yaml:"endregister_date,omitempty"`
	StartEvent      null.Time         `boil:"start_event" json:"start_event,omitempty" toml:"start_event" yaml:"start_event,omitempty"`
	EndEvent        null.Time         `boil:"end_event" json:"end_event,omitempty" toml:"end_event" yaml:"end_event,omitempty"`
	CreatedAt       null.Time         `boil:"created_at" json:"created_at,omitempty" toml:"created_at" yaml:"created_at,omitempty"`
	UpdatedAt       null.Time         `boil:"updated_at" json:"updated_at,omitempty" toml:"updated_at" yaml:"updated_at,omitempty"`
	Latitude        null.String       `boil:"latitude" json:"latitude,omitempty" toml:"latitude" yaml:"latitude,omitempty"`
	Longitude       null.String       `boil:"longitude" json:"longitude,omitempty" toml:"longitude" yaml:"longitude,omitempty"`
	Title           null.String       `boil:"title" json:"title,omitempty" toml:"title" yaml:"title,omitempty"`
	Description     null.String       `boil:"description" json:"description,omitempty" toml:"description" yaml:"description,omitempty"`
	AverageRating   null.Float64      `boil:"average_rating" json:"average_rating,omitempty" toml:"average_rating" yaml:"average_rating,omitempty"`
	IsFinished      null.Bool         `boil:"is_finished" json:"is_finished,omitempty" toml:"is_finished" yaml:"is_finished,omitempty"`
	IsOnline        null.Bool         `boil:"is_online" json:"is_online,omitempty" toml:"is_online" yaml:"is_online,omitempty"`
	Tags            types.StringArray `boil:"tags" json:"tags,omitempty" toml:"tags" yaml:"tags,omitempty"`
	FeaturedImages  types.StringArray `boil:"featured_images" json:"featured_images,omitempty" toml:"featured_images" yaml:"featured_images,omitempty"`
	GuestStar       types.StringArray `boil:"guest_star" json:"guest_star,omitempty" toml:"guest_star" yaml:"guest_star,omitempty"`
	Location        null.String       `boil:"location" json:"location,omitempty" toml:"location" yaml:"location,omitempty"`
	ID              int               `boil:"id" json:"id" toml:"id" yaml:"id"`

	R *eventR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L eventL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var EventColumns = struct {
	EventcreatorID  string
	Category        string
	PreregisterDate string
	EndregisterDate string
	StartEvent      string
	EndEvent        string
	CreatedAt       string
	UpdatedAt       string
	Latitude        string
	Longitude       string
	Title           string
	Description     string
	AverageRating   string
	IsFinished      string
	IsOnline        string
	Tags            string
	FeaturedImages  string
	GuestStar       string
	Location        string
	ID              string
}{
	EventcreatorID:  "eventcreator_id",
	Category:        "category",
	PreregisterDate: "preregister_date",
	EndregisterDate: "endregister_date",
	StartEvent:      "start_event",
	EndEvent:        "end_event",
	CreatedAt:       "created_at",
	UpdatedAt:       "updated_at",
	Latitude:        "latitude",
	Longitude:       "longitude",
	Title:           "title",
	Description:     "description",
	AverageRating:   "average_rating",
	IsFinished:      "is_finished",
	IsOnline:        "is_online",
	Tags:            "tags",
	FeaturedImages:  "featured_images",
	GuestStar:       "guest_star",
	Location:        "location",
	ID:              "id",
}

var EventTableColumns = struct {
	EventcreatorID  string
	Category        string
	PreregisterDate string
	EndregisterDate string
	StartEvent      string
	EndEvent        string
	CreatedAt       string
	UpdatedAt       string
	Latitude        string
	Longitude       string
	Title           string
	Description     string
	AverageRating   string
	IsFinished      string
	IsOnline        string
	Tags            string
	FeaturedImages  string
	GuestStar       string
	Location        string
	ID              string
}{
	EventcreatorID:  "events.eventcreator_id",
	Category:        "events.category",
	PreregisterDate: "events.preregister_date",
	EndregisterDate: "events.endregister_date",
	StartEvent:      "events.start_event",
	EndEvent:        "events.end_event",
	CreatedAt:       "events.created_at",
	UpdatedAt:       "events.updated_at",
	Latitude:        "events.latitude",
	Longitude:       "events.longitude",
	Title:           "events.title",
	Description:     "events.description",
	AverageRating:   "events.average_rating",
	IsFinished:      "events.is_finished",
	IsOnline:        "events.is_online",
	Tags:            "events.tags",
	FeaturedImages:  "events.featured_images",
	GuestStar:       "events.guest_star",
	Location:        "events.location",
	ID:              "events.id",
}

// Generated where

type whereHelpertypes_StringArray struct{ field string }

func (w whereHelpertypes_StringArray) EQ(x types.StringArray) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpertypes_StringArray) NEQ(x types.StringArray) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpertypes_StringArray) LT(x types.StringArray) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpertypes_StringArray) LTE(x types.StringArray) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpertypes_StringArray) GT(x types.StringArray) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpertypes_StringArray) GTE(x types.StringArray) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

func (w whereHelpertypes_StringArray) IsNull() qm.QueryMod { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpertypes_StringArray) IsNotNull() qm.QueryMod {
	return qmhelper.WhereIsNotNull(w.field)
}

type whereHelpernull_Float64 struct{ field string }

func (w whereHelpernull_Float64) EQ(x null.Float64) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Float64) NEQ(x null.Float64) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Float64) LT(x null.Float64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Float64) LTE(x null.Float64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Float64) GT(x null.Float64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Float64) GTE(x null.Float64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}
func (w whereHelpernull_Float64) IN(slice []float64) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelpernull_Float64) NIN(slice []float64) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

func (w whereHelpernull_Float64) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Float64) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

type whereHelpernull_Bool struct{ field string }

func (w whereHelpernull_Bool) EQ(x null.Bool) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Bool) NEQ(x null.Bool) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Bool) LT(x null.Bool) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Bool) LTE(x null.Bool) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Bool) GT(x null.Bool) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Bool) GTE(x null.Bool) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

func (w whereHelpernull_Bool) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Bool) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

var EventWhere = struct {
	EventcreatorID  whereHelpernull_Int
	Category        whereHelpertypes_StringArray
	PreregisterDate whereHelpernull_Time
	EndregisterDate whereHelpernull_Time
	StartEvent      whereHelpernull_Time
	EndEvent        whereHelpernull_Time
	CreatedAt       whereHelpernull_Time
	UpdatedAt       whereHelpernull_Time
	Latitude        whereHelpernull_String
	Longitude       whereHelpernull_String
	Title           whereHelpernull_String
	Description     whereHelpernull_String
	AverageRating   whereHelpernull_Float64
	IsFinished      whereHelpernull_Bool
	IsOnline        whereHelpernull_Bool
	Tags            whereHelpertypes_StringArray
	FeaturedImages  whereHelpertypes_StringArray
	GuestStar       whereHelpertypes_StringArray
	Location        whereHelpernull_String
	ID              whereHelperint
}{
	EventcreatorID:  whereHelpernull_Int{field: "\"events\".\"eventcreator_id\""},
	Category:        whereHelpertypes_StringArray{field: "\"events\".\"category\""},
	PreregisterDate: whereHelpernull_Time{field: "\"events\".\"preregister_date\""},
	EndregisterDate: whereHelpernull_Time{field: "\"events\".\"endregister_date\""},
	StartEvent:      whereHelpernull_Time{field: "\"events\".\"start_event\""},
	EndEvent:        whereHelpernull_Time{field: "\"events\".\"end_event\""},
	CreatedAt:       whereHelpernull_Time{field: "\"events\".\"created_at\""},
	UpdatedAt:       whereHelpernull_Time{field: "\"events\".\"updated_at\""},
	Latitude:        whereHelpernull_String{field: "\"events\".\"latitude\""},
	Longitude:       whereHelpernull_String{field: "\"events\".\"longitude\""},
	Title:           whereHelpernull_String{field: "\"events\".\"title\""},
	Description:     whereHelpernull_String{field: "\"events\".\"description\""},
	AverageRating:   whereHelpernull_Float64{field: "\"events\".\"average_rating\""},
	IsFinished:      whereHelpernull_Bool{field: "\"events\".\"is_finished\""},
	IsOnline:        whereHelpernull_Bool{field: "\"events\".\"is_online\""},
	Tags:            whereHelpertypes_StringArray{field: "\"events\".\"tags\""},
	FeaturedImages:  whereHelpertypes_StringArray{field: "\"events\".\"featured_images\""},
	GuestStar:       whereHelpertypes_StringArray{field: "\"events\".\"guest_star\""},
	Location:        whereHelpernull_String{field: "\"events\".\"location\""},
	ID:              whereHelperint{field: "\"events\".\"id\""},
}

// EventRels is where relationship names are stored.
var EventRels = struct {
	Eventcreator    string
	EventCategories string
	EventsBookmarks string
	EventsViews     string
	Ratings         string
	Tickets         string
}{
	Eventcreator:    "Eventcreator",
	EventCategories: "EventCategories",
	EventsBookmarks: "EventsBookmarks",
	EventsViews:     "EventsViews",
	Ratings:         "Ratings",
	Tickets:         "Tickets",
}

// eventR is where relationships are stored.
type eventR struct {
	Eventcreator    *EventCreator       `boil:"Eventcreator" json:"Eventcreator" toml:"Eventcreator" yaml:"Eventcreator"`
	EventCategories EventCategorySlice  `boil:"EventCategories" json:"EventCategories" toml:"EventCategories" yaml:"EventCategories"`
	EventsBookmarks EventsBookmarkSlice `boil:"EventsBookmarks" json:"EventsBookmarks" toml:"EventsBookmarks" yaml:"EventsBookmarks"`
	EventsViews     EventsViewSlice     `boil:"EventsViews" json:"EventsViews" toml:"EventsViews" yaml:"EventsViews"`
	Ratings         RatingSlice         `boil:"Ratings" json:"Ratings" toml:"Ratings" yaml:"Ratings"`
	Tickets         TicketSlice         `boil:"Tickets" json:"Tickets" toml:"Tickets" yaml:"Tickets"`
}

// NewStruct creates a new relationship struct
func (*eventR) NewStruct() *eventR {
	return &eventR{}
}

func (r *eventR) GetEventcreator() *EventCreator {
	if r == nil {
		return nil
	}
	return r.Eventcreator
}

func (r *eventR) GetEventCategories() EventCategorySlice {
	if r == nil {
		return nil
	}
	return r.EventCategories
}

func (r *eventR) GetEventsBookmarks() EventsBookmarkSlice {
	if r == nil {
		return nil
	}
	return r.EventsBookmarks
}

func (r *eventR) GetEventsViews() EventsViewSlice {
	if r == nil {
		return nil
	}
	return r.EventsViews
}

func (r *eventR) GetRatings() RatingSlice {
	if r == nil {
		return nil
	}
	return r.Ratings
}

func (r *eventR) GetTickets() TicketSlice {
	if r == nil {
		return nil
	}
	return r.Tickets
}

// eventL is where Load methods for each relationship are stored.
type eventL struct{}

var (
	eventAllColumns            = []string{"eventcreator_id", "category", "preregister_date", "endregister_date", "start_event", "end_event", "created_at", "updated_at", "latitude", "longitude", "title", "description", "average_rating", "is_finished", "is_online", "tags", "featured_images", "guest_star", "location", "id"}
	eventColumnsWithoutDefault = []string{}
	eventColumnsWithDefault    = []string{"eventcreator_id", "category", "preregister_date", "endregister_date", "start_event", "end_event", "created_at", "updated_at", "latitude", "longitude", "title", "description", "average_rating", "is_finished", "is_online", "tags", "featured_images", "guest_star", "location", "id"}
	eventPrimaryKeyColumns     = []string{"id"}
	eventGeneratedColumns      = []string{"id"}
)

type (
	// EventSlice is an alias for a slice of pointers to Event.
	// This should almost always be used instead of []Event.
	EventSlice []*Event
	// EventHook is the signature for custom Event hook methods
	EventHook func(context.Context, boil.ContextExecutor, *Event) error

	eventQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	eventType                 = reflect.TypeOf(&Event{})
	eventMapping              = queries.MakeStructMapping(eventType)
	eventPrimaryKeyMapping, _ = queries.BindMapping(eventType, eventMapping, eventPrimaryKeyColumns)
	eventInsertCacheMut       sync.RWMutex
	eventInsertCache          = make(map[string]insertCache)
	eventUpdateCacheMut       sync.RWMutex
	eventUpdateCache          = make(map[string]updateCache)
	eventUpsertCacheMut       sync.RWMutex
	eventUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var eventAfterSelectHooks []EventHook

var eventBeforeInsertHooks []EventHook
var eventAfterInsertHooks []EventHook

var eventBeforeUpdateHooks []EventHook
var eventAfterUpdateHooks []EventHook

var eventBeforeDeleteHooks []EventHook
var eventAfterDeleteHooks []EventHook

var eventBeforeUpsertHooks []EventHook
var eventAfterUpsertHooks []EventHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *Event) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range eventAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *Event) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range eventBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *Event) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range eventAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *Event) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range eventBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *Event) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range eventAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *Event) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range eventBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *Event) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range eventAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *Event) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range eventBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *Event) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range eventAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddEventHook registers your hook function for all future operations.
func AddEventHook(hookPoint boil.HookPoint, eventHook EventHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		eventAfterSelectHooks = append(eventAfterSelectHooks, eventHook)
	case boil.BeforeInsertHook:
		eventBeforeInsertHooks = append(eventBeforeInsertHooks, eventHook)
	case boil.AfterInsertHook:
		eventAfterInsertHooks = append(eventAfterInsertHooks, eventHook)
	case boil.BeforeUpdateHook:
		eventBeforeUpdateHooks = append(eventBeforeUpdateHooks, eventHook)
	case boil.AfterUpdateHook:
		eventAfterUpdateHooks = append(eventAfterUpdateHooks, eventHook)
	case boil.BeforeDeleteHook:
		eventBeforeDeleteHooks = append(eventBeforeDeleteHooks, eventHook)
	case boil.AfterDeleteHook:
		eventAfterDeleteHooks = append(eventAfterDeleteHooks, eventHook)
	case boil.BeforeUpsertHook:
		eventBeforeUpsertHooks = append(eventBeforeUpsertHooks, eventHook)
	case boil.AfterUpsertHook:
		eventAfterUpsertHooks = append(eventAfterUpsertHooks, eventHook)
	}
}

// One returns a single event record from the query.
func (q eventQuery) One(ctx context.Context, exec boil.ContextExecutor) (*Event, error) {
	o := &Event{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for events")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all Event records from the query.
func (q eventQuery) All(ctx context.Context, exec boil.ContextExecutor) (EventSlice, error) {
	var o []*Event

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to Event slice")
	}

	if len(eventAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all Event records in the query.
func (q eventQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count events rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q eventQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if events exists")
	}

	return count > 0, nil
}

// Eventcreator pointed to by the foreign key.
func (o *Event) Eventcreator(mods ...qm.QueryMod) eventCreatorQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.EventcreatorID),
	}

	queryMods = append(queryMods, mods...)

	return EventCreators(queryMods...)
}

// EventCategories retrieves all the event_category's EventCategories with an executor.
func (o *Event) EventCategories(mods ...qm.QueryMod) eventCategoryQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"event_category\".\"event_id\"=?", o.ID),
	)

	return EventCategories(queryMods...)
}

// EventsBookmarks retrieves all the events_bookmark's EventsBookmarks with an executor.
func (o *Event) EventsBookmarks(mods ...qm.QueryMod) eventsBookmarkQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"events_bookmark\".\"event_id\"=?", o.ID),
	)

	return EventsBookmarks(queryMods...)
}

// EventsViews retrieves all the events_view's EventsViews with an executor.
func (o *Event) EventsViews(mods ...qm.QueryMod) eventsViewQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"events_views\".\"event_id\"=?", o.ID),
	)

	return EventsViews(queryMods...)
}

// Ratings retrieves all the rating's Ratings with an executor.
func (o *Event) Ratings(mods ...qm.QueryMod) ratingQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"rating\".\"event_id\"=?", o.ID),
	)

	return Ratings(queryMods...)
}

// Tickets retrieves all the ticket's Tickets with an executor.
func (o *Event) Tickets(mods ...qm.QueryMod) ticketQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"tickets\".\"event_id\"=?", o.ID),
	)

	return Tickets(queryMods...)
}

// LoadEventcreator allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (eventL) LoadEventcreator(ctx context.Context, e boil.ContextExecutor, singular bool, maybeEvent interface{}, mods queries.Applicator) error {
	var slice []*Event
	var object *Event

	if singular {
		var ok bool
		object, ok = maybeEvent.(*Event)
		if !ok {
			object = new(Event)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeEvent)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeEvent))
			}
		}
	} else {
		s, ok := maybeEvent.(*[]*Event)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeEvent)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeEvent))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &eventR{}
		}
		if !queries.IsNil(object.EventcreatorID) {
			args = append(args, object.EventcreatorID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &eventR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.EventcreatorID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.EventcreatorID) {
				args = append(args, obj.EventcreatorID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`event_creators`),
		qm.WhereIn(`event_creators.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load EventCreator")
	}

	var resultSlice []*EventCreator
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice EventCreator")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for event_creators")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for event_creators")
	}

	if len(eventCreatorAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Eventcreator = foreign
		if foreign.R == nil {
			foreign.R = &eventCreatorR{}
		}
		foreign.R.EventcreatorEvents = append(foreign.R.EventcreatorEvents, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.EventcreatorID, foreign.ID) {
				local.R.Eventcreator = foreign
				if foreign.R == nil {
					foreign.R = &eventCreatorR{}
				}
				foreign.R.EventcreatorEvents = append(foreign.R.EventcreatorEvents, local)
				break
			}
		}
	}

	return nil
}

// LoadEventCategories allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (eventL) LoadEventCategories(ctx context.Context, e boil.ContextExecutor, singular bool, maybeEvent interface{}, mods queries.Applicator) error {
	var slice []*Event
	var object *Event

	if singular {
		var ok bool
		object, ok = maybeEvent.(*Event)
		if !ok {
			object = new(Event)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeEvent)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeEvent))
			}
		}
	} else {
		s, ok := maybeEvent.(*[]*Event)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeEvent)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeEvent))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &eventR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &eventR{}
			}

			for _, a := range args {
				if a == obj.ID {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`event_category`),
		qm.WhereIn(`event_category.event_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load event_category")
	}

	var resultSlice []*EventCategory
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice event_category")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on event_category")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for event_category")
	}

	if len(eventCategoryAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.EventCategories = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &eventCategoryR{}
			}
			foreign.R.Event = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.EventID {
				local.R.EventCategories = append(local.R.EventCategories, foreign)
				if foreign.R == nil {
					foreign.R = &eventCategoryR{}
				}
				foreign.R.Event = local
				break
			}
		}
	}

	return nil
}

// LoadEventsBookmarks allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (eventL) LoadEventsBookmarks(ctx context.Context, e boil.ContextExecutor, singular bool, maybeEvent interface{}, mods queries.Applicator) error {
	var slice []*Event
	var object *Event

	if singular {
		var ok bool
		object, ok = maybeEvent.(*Event)
		if !ok {
			object = new(Event)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeEvent)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeEvent))
			}
		}
	} else {
		s, ok := maybeEvent.(*[]*Event)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeEvent)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeEvent))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &eventR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &eventR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`events_bookmark`),
		qm.WhereIn(`events_bookmark.event_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load events_bookmark")
	}

	var resultSlice []*EventsBookmark
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice events_bookmark")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on events_bookmark")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for events_bookmark")
	}

	if len(eventsBookmarkAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.EventsBookmarks = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &eventsBookmarkR{}
			}
			foreign.R.Event = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.EventID) {
				local.R.EventsBookmarks = append(local.R.EventsBookmarks, foreign)
				if foreign.R == nil {
					foreign.R = &eventsBookmarkR{}
				}
				foreign.R.Event = local
				break
			}
		}
	}

	return nil
}

// LoadEventsViews allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (eventL) LoadEventsViews(ctx context.Context, e boil.ContextExecutor, singular bool, maybeEvent interface{}, mods queries.Applicator) error {
	var slice []*Event
	var object *Event

	if singular {
		var ok bool
		object, ok = maybeEvent.(*Event)
		if !ok {
			object = new(Event)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeEvent)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeEvent))
			}
		}
	} else {
		s, ok := maybeEvent.(*[]*Event)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeEvent)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeEvent))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &eventR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &eventR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`events_views`),
		qm.WhereIn(`events_views.event_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load events_views")
	}

	var resultSlice []*EventsView
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice events_views")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on events_views")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for events_views")
	}

	if len(eventsViewAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.EventsViews = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &eventsViewR{}
			}
			foreign.R.Event = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.EventID) {
				local.R.EventsViews = append(local.R.EventsViews, foreign)
				if foreign.R == nil {
					foreign.R = &eventsViewR{}
				}
				foreign.R.Event = local
				break
			}
		}
	}

	return nil
}

// LoadRatings allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (eventL) LoadRatings(ctx context.Context, e boil.ContextExecutor, singular bool, maybeEvent interface{}, mods queries.Applicator) error {
	var slice []*Event
	var object *Event

	if singular {
		var ok bool
		object, ok = maybeEvent.(*Event)
		if !ok {
			object = new(Event)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeEvent)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeEvent))
			}
		}
	} else {
		s, ok := maybeEvent.(*[]*Event)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeEvent)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeEvent))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &eventR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &eventR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`rating`),
		qm.WhereIn(`rating.event_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load rating")
	}

	var resultSlice []*Rating
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice rating")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on rating")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for rating")
	}

	if len(ratingAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.Ratings = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &ratingR{}
			}
			foreign.R.Event = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.EventID) {
				local.R.Ratings = append(local.R.Ratings, foreign)
				if foreign.R == nil {
					foreign.R = &ratingR{}
				}
				foreign.R.Event = local
				break
			}
		}
	}

	return nil
}

// LoadTickets allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (eventL) LoadTickets(ctx context.Context, e boil.ContextExecutor, singular bool, maybeEvent interface{}, mods queries.Applicator) error {
	var slice []*Event
	var object *Event

	if singular {
		var ok bool
		object, ok = maybeEvent.(*Event)
		if !ok {
			object = new(Event)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeEvent)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeEvent))
			}
		}
	} else {
		s, ok := maybeEvent.(*[]*Event)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeEvent)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeEvent))
			}
		}
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &eventR{}
		}
		args = append(args, object.ID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &eventR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ID) {
					continue Outer
				}
			}

			args = append(args, obj.ID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`tickets`),
		qm.WhereIn(`tickets.event_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load tickets")
	}

	var resultSlice []*Ticket
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice tickets")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on tickets")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for tickets")
	}

	if len(ticketAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.Tickets = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &ticketR{}
			}
			foreign.R.Event = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.EventID) {
				local.R.Tickets = append(local.R.Tickets, foreign)
				if foreign.R == nil {
					foreign.R = &ticketR{}
				}
				foreign.R.Event = local
				break
			}
		}
	}

	return nil
}

// SetEventcreator of the event to the related item.
// Sets o.R.Eventcreator to related.
// Adds o to related.R.EventcreatorEvents.
func (o *Event) SetEventcreator(ctx context.Context, exec boil.ContextExecutor, insert bool, related *EventCreator) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"events\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"eventcreator_id"}),
		strmangle.WhereClause("\"", "\"", 2, eventPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.EventcreatorID, related.ID)
	if o.R == nil {
		o.R = &eventR{
			Eventcreator: related,
		}
	} else {
		o.R.Eventcreator = related
	}

	if related.R == nil {
		related.R = &eventCreatorR{
			EventcreatorEvents: EventSlice{o},
		}
	} else {
		related.R.EventcreatorEvents = append(related.R.EventcreatorEvents, o)
	}

	return nil
}

// RemoveEventcreator relationship.
// Sets o.R.Eventcreator to nil.
// Removes o from all passed in related items' relationships struct.
func (o *Event) RemoveEventcreator(ctx context.Context, exec boil.ContextExecutor, related *EventCreator) error {
	var err error

	queries.SetScanner(&o.EventcreatorID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("eventcreator_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.Eventcreator = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.EventcreatorEvents {
		if queries.Equal(o.EventcreatorID, ri.EventcreatorID) {
			continue
		}

		ln := len(related.R.EventcreatorEvents)
		if ln > 1 && i < ln-1 {
			related.R.EventcreatorEvents[i] = related.R.EventcreatorEvents[ln-1]
		}
		related.R.EventcreatorEvents = related.R.EventcreatorEvents[:ln-1]
		break
	}
	return nil
}

// AddEventCategories adds the given related objects to the existing relationships
// of the event, optionally inserting them as new records.
// Appends related to o.R.EventCategories.
// Sets related.R.Event appropriately.
func (o *Event) AddEventCategories(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*EventCategory) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.EventID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"event_category\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"event_id"}),
				strmangle.WhereClause("\"", "\"", 2, eventCategoryPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.EventID = o.ID
		}
	}

	if o.R == nil {
		o.R = &eventR{
			EventCategories: related,
		}
	} else {
		o.R.EventCategories = append(o.R.EventCategories, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &eventCategoryR{
				Event: o,
			}
		} else {
			rel.R.Event = o
		}
	}
	return nil
}

// AddEventsBookmarks adds the given related objects to the existing relationships
// of the event, optionally inserting them as new records.
// Appends related to o.R.EventsBookmarks.
// Sets related.R.Event appropriately.
func (o *Event) AddEventsBookmarks(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*EventsBookmark) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.EventID, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"events_bookmark\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"event_id"}),
				strmangle.WhereClause("\"", "\"", 2, eventsBookmarkPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.EventID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &eventR{
			EventsBookmarks: related,
		}
	} else {
		o.R.EventsBookmarks = append(o.R.EventsBookmarks, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &eventsBookmarkR{
				Event: o,
			}
		} else {
			rel.R.Event = o
		}
	}
	return nil
}

// SetEventsBookmarks removes all previously related items of the
// event replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Event's EventsBookmarks accordingly.
// Replaces o.R.EventsBookmarks with related.
// Sets related.R.Event's EventsBookmarks accordingly.
func (o *Event) SetEventsBookmarks(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*EventsBookmark) error {
	query := "update \"events_bookmark\" set \"event_id\" = null where \"event_id\" = $1"
	values := []interface{}{o.ID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.EventsBookmarks {
			queries.SetScanner(&rel.EventID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Event = nil
		}
		o.R.EventsBookmarks = nil
	}

	return o.AddEventsBookmarks(ctx, exec, insert, related...)
}

// RemoveEventsBookmarks relationships from objects passed in.
// Removes related items from R.EventsBookmarks (uses pointer comparison, removal does not keep order)
// Sets related.R.Event.
func (o *Event) RemoveEventsBookmarks(ctx context.Context, exec boil.ContextExecutor, related ...*EventsBookmark) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.EventID, nil)
		if rel.R != nil {
			rel.R.Event = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("event_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.EventsBookmarks {
			if rel != ri {
				continue
			}

			ln := len(o.R.EventsBookmarks)
			if ln > 1 && i < ln-1 {
				o.R.EventsBookmarks[i] = o.R.EventsBookmarks[ln-1]
			}
			o.R.EventsBookmarks = o.R.EventsBookmarks[:ln-1]
			break
		}
	}

	return nil
}

// AddEventsViews adds the given related objects to the existing relationships
// of the event, optionally inserting them as new records.
// Appends related to o.R.EventsViews.
// Sets related.R.Event appropriately.
func (o *Event) AddEventsViews(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*EventsView) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.EventID, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"events_views\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"event_id"}),
				strmangle.WhereClause("\"", "\"", 2, eventsViewPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.EventID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &eventR{
			EventsViews: related,
		}
	} else {
		o.R.EventsViews = append(o.R.EventsViews, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &eventsViewR{
				Event: o,
			}
		} else {
			rel.R.Event = o
		}
	}
	return nil
}

// SetEventsViews removes all previously related items of the
// event replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Event's EventsViews accordingly.
// Replaces o.R.EventsViews with related.
// Sets related.R.Event's EventsViews accordingly.
func (o *Event) SetEventsViews(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*EventsView) error {
	query := "update \"events_views\" set \"event_id\" = null where \"event_id\" = $1"
	values := []interface{}{o.ID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.EventsViews {
			queries.SetScanner(&rel.EventID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Event = nil
		}
		o.R.EventsViews = nil
	}

	return o.AddEventsViews(ctx, exec, insert, related...)
}

// RemoveEventsViews relationships from objects passed in.
// Removes related items from R.EventsViews (uses pointer comparison, removal does not keep order)
// Sets related.R.Event.
func (o *Event) RemoveEventsViews(ctx context.Context, exec boil.ContextExecutor, related ...*EventsView) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.EventID, nil)
		if rel.R != nil {
			rel.R.Event = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("event_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.EventsViews {
			if rel != ri {
				continue
			}

			ln := len(o.R.EventsViews)
			if ln > 1 && i < ln-1 {
				o.R.EventsViews[i] = o.R.EventsViews[ln-1]
			}
			o.R.EventsViews = o.R.EventsViews[:ln-1]
			break
		}
	}

	return nil
}

// AddRatings adds the given related objects to the existing relationships
// of the event, optionally inserting them as new records.
// Appends related to o.R.Ratings.
// Sets related.R.Event appropriately.
func (o *Event) AddRatings(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Rating) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.EventID, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"rating\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"event_id"}),
				strmangle.WhereClause("\"", "\"", 2, ratingPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.EventID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &eventR{
			Ratings: related,
		}
	} else {
		o.R.Ratings = append(o.R.Ratings, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &ratingR{
				Event: o,
			}
		} else {
			rel.R.Event = o
		}
	}
	return nil
}

// SetRatings removes all previously related items of the
// event replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Event's Ratings accordingly.
// Replaces o.R.Ratings with related.
// Sets related.R.Event's Ratings accordingly.
func (o *Event) SetRatings(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Rating) error {
	query := "update \"rating\" set \"event_id\" = null where \"event_id\" = $1"
	values := []interface{}{o.ID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.Ratings {
			queries.SetScanner(&rel.EventID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Event = nil
		}
		o.R.Ratings = nil
	}

	return o.AddRatings(ctx, exec, insert, related...)
}

// RemoveRatings relationships from objects passed in.
// Removes related items from R.Ratings (uses pointer comparison, removal does not keep order)
// Sets related.R.Event.
func (o *Event) RemoveRatings(ctx context.Context, exec boil.ContextExecutor, related ...*Rating) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.EventID, nil)
		if rel.R != nil {
			rel.R.Event = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("event_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.Ratings {
			if rel != ri {
				continue
			}

			ln := len(o.R.Ratings)
			if ln > 1 && i < ln-1 {
				o.R.Ratings[i] = o.R.Ratings[ln-1]
			}
			o.R.Ratings = o.R.Ratings[:ln-1]
			break
		}
	}

	return nil
}

// AddTickets adds the given related objects to the existing relationships
// of the event, optionally inserting them as new records.
// Appends related to o.R.Tickets.
// Sets related.R.Event appropriately.
func (o *Event) AddTickets(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Ticket) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.EventID, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"tickets\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"event_id"}),
				strmangle.WhereClause("\"", "\"", 2, ticketPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.EventID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &eventR{
			Tickets: related,
		}
	} else {
		o.R.Tickets = append(o.R.Tickets, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &ticketR{
				Event: o,
			}
		} else {
			rel.R.Event = o
		}
	}
	return nil
}

// SetTickets removes all previously related items of the
// event replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Event's Tickets accordingly.
// Replaces o.R.Tickets with related.
// Sets related.R.Event's Tickets accordingly.
func (o *Event) SetTickets(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Ticket) error {
	query := "update \"tickets\" set \"event_id\" = null where \"event_id\" = $1"
	values := []interface{}{o.ID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.Tickets {
			queries.SetScanner(&rel.EventID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Event = nil
		}
		o.R.Tickets = nil
	}

	return o.AddTickets(ctx, exec, insert, related...)
}

// RemoveTickets relationships from objects passed in.
// Removes related items from R.Tickets (uses pointer comparison, removal does not keep order)
// Sets related.R.Event.
func (o *Event) RemoveTickets(ctx context.Context, exec boil.ContextExecutor, related ...*Ticket) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.EventID, nil)
		if rel.R != nil {
			rel.R.Event = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("event_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.Tickets {
			if rel != ri {
				continue
			}

			ln := len(o.R.Tickets)
			if ln > 1 && i < ln-1 {
				o.R.Tickets[i] = o.R.Tickets[ln-1]
			}
			o.R.Tickets = o.R.Tickets[:ln-1]
			break
		}
	}

	return nil
}

// Events retrieves all the records using an executor.
func Events(mods ...qm.QueryMod) eventQuery {
	mods = append(mods, qm.From("\"events\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"events\".*"})
	}

	return eventQuery{q}
}

// FindEvent retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindEvent(ctx context.Context, exec boil.ContextExecutor, iD int, selectCols ...string) (*Event, error) {
	eventObj := &Event{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"events\" where \"id\"=$1", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, eventObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from events")
	}

	if err = eventObj.doAfterSelectHooks(ctx, exec); err != nil {
		return eventObj, err
	}

	return eventObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Event) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no events provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if queries.MustTime(o.CreatedAt).IsZero() {
			queries.SetScanner(&o.CreatedAt, currTime)
		}
		if queries.MustTime(o.UpdatedAt).IsZero() {
			queries.SetScanner(&o.UpdatedAt, currTime)
		}
	}

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(eventColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	eventInsertCacheMut.RLock()
	cache, cached := eventInsertCache[key]
	eventInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			eventAllColumns,
			eventColumnsWithDefault,
			eventColumnsWithoutDefault,
			nzDefaults,
		)
		wl = strmangle.SetComplement(wl, eventGeneratedColumns)

		cache.valueMapping, err = queries.BindMapping(eventType, eventMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(eventType, eventMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"events\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"events\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into events")
	}

	if !cached {
		eventInsertCacheMut.Lock()
		eventInsertCache[key] = cache
		eventInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the Event.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Event) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		queries.SetScanner(&o.UpdatedAt, currTime)
	}

	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	eventUpdateCacheMut.RLock()
	cache, cached := eventUpdateCache[key]
	eventUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			eventAllColumns,
			eventPrimaryKeyColumns,
		)
		wl = strmangle.SetComplement(wl, eventGeneratedColumns)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update events, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"events\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, eventPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(eventType, eventMapping, append(wl, eventPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update events row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for events")
	}

	if !cached {
		eventUpdateCacheMut.Lock()
		eventUpdateCache[key] = cache
		eventUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q eventQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for events")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for events")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o EventSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), eventPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"events\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, eventPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in event slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all event")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Event) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no events provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if queries.MustTime(o.CreatedAt).IsZero() {
			queries.SetScanner(&o.CreatedAt, currTime)
		}
		queries.SetScanner(&o.UpdatedAt, currTime)
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(eventColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	eventUpsertCacheMut.RLock()
	cache, cached := eventUpsertCache[key]
	eventUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			eventAllColumns,
			eventColumnsWithDefault,
			eventColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			eventAllColumns,
			eventPrimaryKeyColumns,
		)

		insert = strmangle.SetComplement(insert, eventGeneratedColumns)
		update = strmangle.SetComplement(update, eventGeneratedColumns)

		if updateOnConflict && len(update) == 0 {
			return errors.New("models: unable to upsert events, could not build update column list")
		}

		conflict := conflictColumns
		if len(conflict) == 0 {
			conflict = make([]string, len(eventPrimaryKeyColumns))
			copy(conflict, eventPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"events\"", updateOnConflict, ret, update, conflict, insert)

		cache.valueMapping, err = queries.BindMapping(eventType, eventMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(eventType, eventMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "models: unable to upsert events")
	}

	if !cached {
		eventUpsertCacheMut.Lock()
		eventUpsertCache[key] = cache
		eventUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single Event record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Event) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no Event provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), eventPrimaryKeyMapping)
	sql := "DELETE FROM \"events\" WHERE \"id\"=$1"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from events")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for events")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q eventQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no eventQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from events")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for events")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o EventSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(eventBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), eventPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"events\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, eventPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from event slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for events")
	}

	if len(eventAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Event) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindEvent(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *EventSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := EventSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), eventPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"events\".* FROM \"events\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, eventPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in EventSlice")
	}

	*o = slice

	return nil
}

// EventExists checks if the Event row exists.
func EventExists(ctx context.Context, exec boil.ContextExecutor, iD int) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"events\" where \"id\"=$1 limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if events exists")
	}

	return exists, nil
}

// Exists checks if the Event row exists.
func (o *Event) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	return EventExists(ctx, exec, o.ID)
}
